# Chris Layden

import numpy as np
import matplotlib.pyplot as plt
import pysynphot as S
from Observatory import Sensor, Telescope, Observatory
from Instruments import imx455, imx487, mono_tele_v10, mono_tele_v8
from scipy import special, integrate
from PSFs import *

if __name__ == '__main__':
    mag_sp = S.FlatSpectrum(fluxdensity=10.0, fluxunits='abmag')
    mag_sp.convert('fnu')
    tess_geo_obs = Observatory(telescope=mono_tele_v10, sensor=imx455,
                               filter_bandpass=1.,
                               exposure_time=1, num_exposures=1)

    # The total number of electrons that are generated by
    # the source across the entire sensor
    signal = round(tess_geo_obs.tot_signal(mag_sp))
    # The single pixel noise in the system (sum of
    # read noise, dark current, and background)
    noise_per_pix = tess_geo_obs.single_pix_noise()

    # The width of a small square of pixels containing the image.
    # Make sure this is odd, so that the image is centered on
    # a pixel, not on a corner.
    num_pix = 9
    # The resolution of the PSF on each pixel
    resolution = 101
    grid_width = num_pix * resolution

    # The RMS jitter on the timescale of one exposure, in units of pixels
    jitter = 0.1
    # The covariance matrix of the Gaussian PSF, in units of pixels
    # Otherwise, if the system is diffraction-limited, find the
    # pivot wavelength of the observation.
    psf_sigma = np.array([[0.5, 0], [0, 0.5]])
    lambda_pivot = tess_geo_obs.lambda_pivot(mag_sp)
    # The non-uniformity in QE between sensor pixels, represented as a
    # standard deviation of a Gaussian distribution with mean 1.
    nonuniformity = 0.0
    relative_qe_grid = np.random.normal(loc=1, scale=nonuniformity,
                                        size=(num_pix, num_pix))

    # # Place the image centroid at a random position on the central pixel
    # start_pos_x = np.random.uniform() - 0.5
    # start_pos_y = np.random.uniform() - 0.5
    # start_pos = np.array([start_pos_x, start_pos_y])
    start_pos = np.array([0, 0])

    # Add the PSF with the appropriate position and scale
    base_grid = multivariate_gaussian(num_pix, resolution, 3.76, start_pos,
                                      psf_sigma)
    # base_grid = airy_disk(num_pix, resolution, tess_geo_obs.sensor.pix_size,
    #                       start_pos, tess_geo_obs.telescope.f_num, lambda_pivot)
    base_grid *= signal
    # Sum the signals within each pixel
    temp_grid = base_grid.reshape((num_pix, resolution, num_pix,
                                   resolution))
    pixel_grid = temp_grid.sum(axis=(1, 3))
    # Determine the optimal aperture for the image
    optimal_ap, n_aper = optimal_aperature(pixel_grid, noise_per_pix)
    obs_grid = pixel_grid * relative_qe_grid * optimal_ap

    true_signal = obs_grid.sum()
    true_noise = np.sqrt(true_signal + n_aper * noise_per_pix)
    # print(true_signal, true_noise, true_signal / true_noise * np.sqrt(3))
    # print(np.max(obs_grid) / signal)
    # print(optimal_ap)
    # print(true_signal / pixel_grid.sum())
    # fig, ax = plt.subplots()
    plt.imshow(base_grid)
    plt.colorbar()
    plt.show()
    # t1 = time.time()

    # num_stacks = 45
    # signal_list = np.zeros(num_stacks * 30)
    # for i in range(num_stacks * 30):
    #     # Do one jitter step
    #     angle = np.random.uniform(low=0.0, high=2*np.pi)
    #     displacement = np.random.normal(scale=jitter * resolution)
    #     x_shift = round(np.cos(angle) * displacement)
    #     y_shift = round(np.sin(angle) * displacement)
    #     shifted_grid = np.roll(np.roll(base_grid, x_shift, axis=1),
    #                            -y_shift, axis=0)
    #     temp_grid = shifted_grid.reshape((num_pix, resolution, num_pix,
    #                                       resolution))
    #     pixel_grid = temp_grid.sum(axis=(1, 3))
    #     obs_grid = pixel_grid * relative_qe_grid * optimal_ap

    #     source_sig = obs_grid.sum()
    #     bkg_sig = tess_geo_obs.bkg_per_pix() * n_aper
    #     dark_sig = tess_geo_obs.sensor.dark_current * n_aper
    #     read_noise = tess_geo_obs.sensor.read_noise
    #     raw_signal = (np.random.poisson(source_sig + bkg_sig + dark_sig)
    #                   + n_aper * np.random.normal(scale=read_noise))
    #     signal_list[i] = raw_signal

    # # reshape the array into num_stacks sub-arrays, each with 30 elements
    # sub_arrays = signal_list.reshape((num_stacks, 30))

    # # compute the average of each stack of 30 exposures
    # averages = np.mean(sub_arrays, axis=1)
    # avg_signal = np.mean(signal_list)
    # avg_noise = np.sqrt(avg_signal + n_aper * noise_per_pix)
    # exposure_std = np.std(signal_list)
    # stack_std = np.std(averages)
    # phot_precision = stack_std / avg_signal * 10**6
    # print("Average signal: ", format(avg_signal,'4.0f'), " e-")
    # print("Expected noise: ", format(avg_noise, '4.0f'), " e-")
    # print("Exposure std: ", format(exposure_std, '4.0f'), " e-")
    # print("Stack std: ", format(stack_std, '4.0f'), " e-")
    # print("Photometric Precision: ", format(phot_precision, '4.0f'), " ppm")
    # print("Time required: ", time.time() - t1, " s")

    # # plt.scatter(range(num_stacks * 30), signal_list)
    # # plt.scatter(range(0, num_stacks * 30, 30), averages)
    # # plt.show()
